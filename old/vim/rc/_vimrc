filetype off
filetype plugin indent off

" {{{ options
if has('vim_starting')
	set encoding=utf-8
	set fileencodings=utf-8,sjis,iso-2022-jp,ucs-bom,euc-jp,cp932,default,latin1
	set fileformats=unix,dos,mac
endif
scriptencoding utf-8

if &compatible
	set nocompatible
endif
"set number
set helplang=ja
set signcolumn=yes 
set hidden
set laststatus=2
set mouse=a
" „ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„É¨„Ç∏„Çπ„Çø„Çí‰ΩøÁî®„Åô„Çã autoselect„ÅØ„Çè„Åã„Çâ„Å™„ÅÑ
set clipboard=unnamed,autoselect
" Èü≥„ÇíÈ≥¥„Çâ„Åï„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
set belloff=all
set formatoptions+=mMj
set ambiwidth=double
" Â§ßÊñáÂ≠ó„ÅÆÊã¨Âºß„Çí%„Åß„Éû„ÉÉ„ÉÅ„Åï„Åõ„Çã
set matchpairs+=„Äå:„Äç,Ôºà:Ôºâ
set directory=~
set backupdir=~
set undodir=~
" normal mode„Å´Êàª„Å£„ÅüÂæå„ÇÇ<BS> <DELETE>„ÇíÂäπ„Åã„Åõ„Çã
set backspace=indent,eol,start
set title
let &g:titlestring =
\ "%{expand('%:p:~:.')} %<\(%{fnamemodify(getcwd(), ':~')}\)%(%m%r%w%)"
set nowrap
if !has('gui_running')
  set t_Co=256
endif
set noshowmode
" }}}

" {{{ plugins
call plug#begin()

Plug 'vim-jp/vimdoc-ja'
Plug 'cohama/lexima.vim'
Plug 'machakann/vim-sandwich'
Plug 'mattn/emmet-vim'
Plug 'simeji/winresizer'
Plug 'skanehira/denops-translate.vim'
Plug 'thinca/vim-fontzoom'
Plug 'vim-denops/denops.vim'
Plug 'KeitaNakamura/neodark.vim'
Plug 'cocopon/iceberg.vim'
Plug 'cocopon/pgmnt.vim'
Plug 'yuki-yano/fuzzy-motion.vim'
Plug 'vim-skk/skkeleton'
Plug 'mattn/vim-sonictemplate'
Plug 'morhetz/gruvbox'

" {{{ golang
Plug 'mattn/vim-goimports'
" }}}

" {{{ fern
Plug 'lambdalisue/fern.vim'
Plug 'lambdalisue/fern-git-status.vim'
Plug 'lambdalisue/fern-renderer-nerdfont.vim'
Plug 'lambdalisue/nerdfont.vim'
Plug 'yuki-yano/fern-preview.vim'
" }}}

" {{{ lightline.vim
Plug 'itchyny/lightline.vim'
Plug 'itchyny/vim-gitbranch'
" }}}

" {{{ git
Plug 'lambdalisue/gin.vim'
Plug 'airblade/vim-gitgutter'
" }}}

"{{{ lsp
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'ziglang/zig.vim'
"}}}

"{{{ ddc
Plug 'Shougo/pum.vim'
Plug 'Shougo/ddc.vim'
Plug 'Shougo/ddc-ui-pum'
Plug 'shun/ddc-vim-lsp'
Plug 'Shougo/ddc-around'
Plug 'Shougo/ddc-matcher_head'
Plug 'LumaKernel/ddc-file'
Plug 'Shougo/ddc-sorter_rank'
Plug 'Shougo/ddc-converter_remove_overlap'
Plug 'Shougo/ddc-cmdline-history'
Plug 'Shougo/ddc-cmdline'
"}}}

call plug#end()
" }}}

" {{{ keymaps
"           Mode  | Norm | Ins | Cmd | Vis | Sel | Opr | Term | Lang | ~
"  Command        +------+-----+-----+-----+-----+-----+------+------+ ~
"  [nore]map      |  @   |  -  |  -  |  @  |  @  |  @  |  -   |  -   |
"  n[nore]map     |  @   |  -  |  -  |  -  |  -  |  -  |  -   |  -   |
"  [nore]map!     |  -   |  @  |  @  |  -  |  -  |  -  |  -   |  -   |
"  i[nore]map     |  -   |  @  |  -  |  -  |  -  |  -  |  -   |  -   |
"  c[nore]map     |  -   |  -  |  @  |  -  |  -  |  -  |  -   |  -   |
"  v[nore]map     |  -   |  -  |  -  |  @  |  @  |  -  |  -   |  -   |
"  x[nore]map     |  -   |  -  |  -  |  @  |  -  |  -  |  -   |  -   |
"  s[nore]map     |  -   |  -  |  -  |  -  |  @  |  -  |  -   |  -   |
"  o[nore]map     |  -   |  -  |  -  |  -  |  -  |  @  |  -   |  -   |
"  t[nore]map     |  -   |  -  |  -  |  -  |  -  |  -  |  @   |  -   |
"  l[nore]map     |  -   |  @  |  @  |  -  |  -  |  -  |  -   |  @   |

let g:mapleader = "\<Space>"
nnoremap <Leader> <Nop>
xnoremap <Leader> <Nop>

inoremap <silent> <Up> <C-o>gk
inoremap <silent> <Down> <C-o>gj
nnoremap <silent> <Up> gk
nnoremap <silent> <Down> gj

" expand path
cmap <C-x> <C-r>=expand('%:p:h')<CR>
" expand file 
cmap <C-z> <C-r>=expand('%:p')<CR>

nnoremap <silent> <Leader>ls :<C-u>ls<CR>
nnoremap <silent> <Leader>w :<C-u>w<CR>
nnoremap <silent> <Leader>bn :<C-u>bn<CR>
nnoremap <silent> <Leader>bp :<C-u>bp<CR>
nnoremap <silent> <Leader>bd :<C-u>bd<CR>
nnoremap <silent> <Leader>cd :<C-u>cd %:p:h<CR> :cd<CR>

nnoremap <silent> v2 vi"
nnoremap <silent> v7 vi'
nnoremap <silent> v8 vi(
nnoremap <silent> v[ vi[
nnoremap <silent> v{ vi{
nnoremap <silent> v, vi<

nnoremap <silent> va2 va"
nnoremap <silent> va7 va'
nnoremap <silent> va8 va(
nnoremap <silent> va, va<

nnoremap <silent> c2 ci"
nnoremap <silent> c7 ci'
nnoremap <silent> c8 ci(
nnoremap <silent> c[ ci[
nnoremap <silent> c{ ci{
nnoremap <silent> c, ci<

nnoremap <silent> ca2 ca"
nnoremap <silent> ca7 ca'
nnoremap <silent> ca8 ca(
nnoremap <silent> ca, ca<

nnoremap <silent> <C-j> o<ESC>
nnoremap <silent> <C-j> O<ESC>

nnoremap <silent> \ :<C-u>so $MYVIMRC<CR>

nnoremap <silent> q: :q<CR>
nnoremap <silent> qq: q:

"nnoremap <silent> <C-\> :<C-u>bo term<CR>

" }}}

" {{{ plugin config

" {{{ fern
let g:fern#default_hidden=1
let g:fern#renderer = "nerdfont"
let g:fern#renderer#nerdfont#indent_markers = 1

nnoremap <silent> <Leader>e :<C-u>Fern . -drawer <CR>
nnoremap <silent> <Leader>E :<C-u>Fern . -drawer -toggle<CR>
nnoremap <silent> <C-F> :Fern . -drawer -reveal=%<CR>

function! s:fern_settings() abort
  nmap <silent> <buffer> <C-m> <Plug>(fern-action-move)
  nmap <silent> <buffer> <C-s> <Plug>(fern-action-new-dir)
  nnoremap <buffer> <C-f> <C-W>p
  nmap <silent> <buffer> p     <Plug>(fern-action-preview:toggle)
  nmap <silent> <buffer> <C-p> <Plug>(fern-action-preview:auto:toggle)
  nmap <silent> <buffer> <C-d> <Plug>(fern-action-preview:scroll:down:half)
  nmap <silent> <buffer> <C-u> <Plug>(fern-action-preview:scroll:up:half)
  setlocal signcolumn=no
  setlocal nonumber
endfunction

augroup fern-settings
  autocmd!
  autocmd FileType fern call s:fern_settings()
augroup END
" }}}

" {{{ translate.vim
vmap <Leader>t <Plug>(VTranslate)
" }}}

" {{{ git-gutter
set updatetime=100

let g:gitgutter_sign_added = '+'
let g:gitgutter_sign_modified = '>'
let g:gitgutter_sign_removed = '-'
let g:gitgutter_sign_removed_first_line = '^'
let g:gitgutter_sign_modified_removed = '<'

let g:gitgutter_map_keys = 0

" }}}

"{{{ lsp
let g:lsp_document_code_action_signs_hint = {'text': 'ü™Ñ'}
let g:lsp_diagnostics_signs_error = {'text': '‚ùå'}
let g:lsp_diagnostics_signs_warning = {'text': '‚ö†Ô∏è'} 
let g:lsp_diagnostics_signs_hint = {'text': 'üîé'}
let g:lsp_diagnostics_float_delay = 1500
let g:lsp_diagnostics_float_cursor = 1
let g:lsp_settings_filetype_typescript = ['typescript-language-server', 'eslint-language-server', 'deno']
function! s:on_lsp_buffer_enabled() abort
	setlocal omnifunc=lsp#complete
	setlocal signcolumn=yes
	if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
	nmap <buffer> gdd <plug>(lsp-definition)
	nmap <buffer> gs <plug>(lsp-document-symbol-search)
	nmap <buffer> gS <plug>(lsp-workspace-symbol-search)
	nmap <buffer> gr <plug>(lsp-references)
	nmap <buffer> gi <plug>(lsp-implementation)
	nmap <buffer> gdt <plug>(lsp-type-definition)
	nmap <buffer> <leader>rn <plug>(lsp-rename)
	nmap <buffer> [g <plug>(lsp-previous-diagnostic)
	nmap <buffer> ]g <plug>(lsp-next-diagnostic)
	nmap <buffer> K <plug>(lsp-hover)
	nmap <buffer> <leader>a <plug>(lsp-code-action)
	nmap <buffer> <leader>lsp <plug>(lsp-status)
	nnoremap <buffer> <expr><C-f> lsp#scroll(+4)
	nnoremap <buffer> <expr><C-S-f> lsp#scroll(-4)

	let g:lsp_format_sync_timeout = 1000
	autocmd! BufWritePre *.rs,*.go,*.ts call execute('LspDocumentFormatSync')

	" refer to doc to add more commands
endfunction

augroup lsp_install
	au!
	" call s:on_lsp_buffer_enabled only for languages that has the server registered.
	autocmd User lsp_buffer_enabled call s:on_lsp_buffer_enabled()
augroup END

set foldmethod=expr
	\ foldexpr=lsp#ui#vim#folding#foldexpr()
	\ foldtext=lsp#ui#vim#folding#foldtext()

let g:lsp_fold_enabled = 0

"}}}

"{{{ ddc
call ddc#custom#patch_global('ui', 'pum')
call ddc#custom#patch_global('sources', [
	\ 'around',
	\ 'vim-lsp',
	\ 'file',
	\ 'skkeleton',
	\ ])
call ddc#custom#patch_global('sourceOptions', {
	\ '_': {
	\   'matchers': ['matcher_head'],
	\   'sorters': ['sorter_rank'],
	\   'converters': ['converter_remove_overlap'],
	\ },
	\ 'around': {'mark': 'Around'},
	\ 'vim-lsp': {
	\   'mark': 'LSP', 
	\   'matchers': ['matcher_head'],
	\   'forceCompletionPattern': '\.|:|->|"\w+/*'
	\ },
	\ 'skkeleton': {
	\   'mark': 'skkeleton',
	\   'matches': ['skkeleton'],
	\   'sources': [],
	\   'minAutoCompleteLength': 2
	\ },
	\ 'file': {
	\   'mark': 'file',
	\   'isVolatile': v:true, 
	\   'forceCompletionPattern': '\S/\S*'
	\ },
	\ })

call ddc#custom#patch_global('autoCompleteEvents', [
	\ 'InsertEnter', 'TextChangedI', 'TextChangedP',
	\ ])


call ddc#enable()

inoremap <Tab> <Cmd>call pum#map#insert_relative(+1)<CR>
inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-n> <Cmd>call pum#map#insert_relative(+1)<CR>
inoremap <C-p> <Cmd>call pum#map#insert_relative(-1)<CR>

" }}}

" {{{ neodark
let g:neodark#terminal_transparent = 1
let g:neodark#solid_vertsplit = 1
" }}}

" {{{ lightline
let g:lightline = {
 \ 'colorscheme': 'customeiceberg'
 \}
"let g:lightline = {
" \ 'colorscheme': 'mystatusline'
" \}
let g:lightline.active = {
 \ 'left': [
 \   [ 'mode', 'paste' ],
 \   [ 'readonly', 'filename', 'modified' ],
 \   [ 'gitbranch' ]
 \ ],
 \ 'right': [
 \   [ 'lineinfo' ],
 \   [ 'percent' ],
 \   [ 'fileformat', 'fileencoding', 'filetype' ]
 \ ]
 \}
let g:lightline.inactive = {
 \ 'left': [],
 \ 'right': []
 \ }
let g:lightline.component_function = {
 \ 'mode': 'LightLineMode',
 \ 'gitbranch': 'gitbranch#name'
 \}
let g:lightline.mode_map = {
 \ 'n' : 'N',
 \ 'i' : 'I',
 \ 'R' : 'R',
 \ 'v' : 'V',
 \ 'V' : 'V-L',
 \ "\<C-v>": 'V-',
 \ 'c' : 'C',
 \ 's' : 'S',
 \ 'S' : 'S-L',
 \ "\<C-s>": 'S-B',
 \ 't': 'T',
 \ }

" from https://github.com/thinca/config/blob/4b02d5abcb/dotfiles/dot.vim/vimrc#L2263
let s:skkeleton_modes = {
 \ 'hira': ' „ÅÇ',
 \ 'kata': ' „Ç¢',
 \ 'hankata': ' ÔΩßÔΩ±',
 \ 'zenkaku': ' ÔΩÅ',
 \ }

function! LightLineMode() abort
 if skkeleton#is_enabled() == v:true
	let skk_mode = skkeleton#mode()
	if !empty(skk_mode)
	 return printf(
			\ '%s[%s]', lightline#mode(),
			\ get(s:skkeleton_modes, skk_mode, skk_mode))
	endif
 endif
 return lightline#mode()
endfunction

augroup skkeleton-mode-changed
 autocmd!
 autocmd User skkeleton-mode-changed call LightLineMode()
augroup END

let s:save_cpo = &cpo
set cpo&vim


function! s:build_palette() abort
let colors = iceberg#palette#light#create()
let g = colors.gui
let c = colors.cterm

let p = {
	\ 'normal':   {},
	\ 'inactive': {},
	\ 'insert':   {},
	\ 'replace':  {},
	\ 'visual':   {},
	\ 'command':   {},
	\ 'tabline':  {}}

 let col_base     = [g.statuslinenc_fg, g.statuslinenc_bg, c.statuslinenc_fg, c.statuslinenc_bg]
 let col_edge     = [g.statusline_fg, g.statusline_bg, c.statusline_fg, c.statusline_bg]
 let col_gradient = [g.statusline_fg, g.xline_gradient_bg, c.statusline_fg, c.xline_gradient_bg]
 let col_nc       = [g.statuslinenc_fg, g.statuslinenc_bg, c.statuslinenc_fg, c.statuslinenc_bg]
 let col_tabfill  = [g.statuslinenc_fg, g.statuslinenc_bg, c.statuslinenc_fg, c.statuslinenc_bg]
 let col_normal   = [g.statusline_fg, g.statusline_bg, c.statusline_fg, c.statusline_bg]
 let col_error    = [g.statusline_fg, g.red, c.normal_bg, c.red]
 let col_warning  = [g.statusline_fg, g.orange, c.normal_bg, c.orange]
 let col_insert   = [g.statusline_fg, g.blue, c.normal_bg, c.blue]
 let col_replace  = [g.statusline_fg, g.orange, c.normal_bg, c.orange]
 let col_visual   = [g.statusline_fg, g.purple, c.normal_bg, c.purple]
 let col_command   = [g.statusline_fg, g.green, c.normal_bg, c.green]
 let col_tabsel   = [g.statusline_fg, g.statusline_bg, c.statusline_fg, c.statusline_bg]

 let p.normal.middle = [
	\ col_base]
 let p.normal.left = [
	\ col_normal,
	\ col_gradient]
 let p.normal.right = [
	\ col_edge,
	\ col_gradient]
 let p.normal.error = [
	\ col_error]
 let p.normal.warning = [
	\ col_warning]

 let p.insert.left = [
	\ col_insert,
	\ col_gradient]
 let p.replace.left = [
	\ col_replace,
	\ col_gradient]
 let p.visual.left = [
	\ col_visual,
	\ col_gradient]
 let p.command.left = [
	\ col_command,
	\ col_gradient]

 let p.inactive.middle = [
	\ col_nc]
 let p.inactive.left = [
	\ col_nc,
	\ col_nc]
 let p.inactive.right = [
	\ col_nc,
	\ col_nc]

 let p.tabline.middle = [
	\ col_tabfill]
 let p.tabline.left = [
	\ col_tabfill]
 let p.tabline.tabsel = [
	\ col_tabsel]

 let p.tabline.right = copy(p.normal.right)

 return p
endfunction


let g:lightline#colorscheme#customeiceberg#palette = s:build_palette()


let &cpo = s:save_cpo
unlet s:save_cpo

" }}}

" {{{ fuzzy-motion
nnoremap <Leader><Leader> :<C-u>FuzzyMotion<CR>
let g:fuzzy_motion_word_regexp_list = [
  \ '[0-9a-zA-Z_-]+',
  \ '([0-9a-zA-Z_-]|[.])+',
  \ '([0-9a-zA-Z]|[()<>.-_#''"]|(\s=+\s)|(,\s)|(:\s)|(\s=>\s))+'
  \ ]
" }}}

" {{{ skkeleton
"let g:skkeleton#debug = v:true
function! s:skkeleton_init() abort
 call skkeleton#config({
 \ 'eggLikeNewline': v:true,
 \ "globalDictionaries": [
 \  ["C:\\Program Files\\skk\\SKK-JISYO.L", "euc-jp"],
 \  ["C:\\Program Files\\skk\\SKK-JISYO.geo", "euc-jp"],
 \  ["C:\\Program Files\\skk\\SKK-JISYO.jinmei", "euc-jp"],
 \  ["C:\\Program Files\\skk\\SKK-JISYO.propernoun", "euc-jp"],
 \  ["C:\\Program Files\\skk\\SKK-JISYO.station", "euc-jp"]
 \ ]
 \})
 call skkeleton#register_kanatable('rom', {
 \ "z\<Space>": ["\u3000", ''],
 \})
endfunction

augroup skkeleton-initialize-pre
 autocmd!
 autocmd User skkeleton-initialize-pre call s:skkeleton_init()
augroup END

imap <C-j> <Plug>(skkeleton-toggle)
cmap <C-j> <Plug>(skkeleton-toggle)
" }}}

" }}}

" {{{ commands
augroup restore-cursor
	autocmd!
	autocmd BufReadPost *
		\ : if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
		\ |   exe "normal! g`\""
		\ | endif

		\ : if empty(&buftype) && line('.') > winheight(0) / 2
		\ |   execute 'normal! zz'
		\ | endif
augroup END

augroup fileTypeIndent
	autocmd!
	autocmd BufNewFile,BufRead _vimrc setlocal tabstop=2 shiftwidth=1
augroup END

autocmd FileType vim setlocal foldmethod=marker

let s:termname = '__terminal__'
function! s:open() abort
 if bufexists(s:termname)
	botright split
	call execute('buffer ' .. s:termname)
	startinsert
 else
	if has('nvim')
	 botright split | terminal
	else
	 botright terminal
	endif
	startinsert
	call execute('file ' .. s:termname)
	setl nobuflisted
 endif
endfunction
function! s:close(pane) abort
 call execute(a:pane . 'wincmd c')
endfunction
function! s:toggle() abort
 let pane = bufwinnr(s:termname)
 if pane > -1
	call s:close(pane)
 else
	call s:open()
 endif
endfunction
command! -nargs=0 TerminalToggle call s:toggle()
nnoremap <silent> <C-\> <cmd>TerminalToggle<CR>
tnoremap <silent> <C-\> <cmd>TerminalToggle<CR>

function! s:create_zenn_article(article_name) abort
  let date = strftime("%Y-%m-%d")
  let slug = date . "-" . a:article_name
	call system("npx zenn new:article --slug " . slug)
  let article_path = "articles/" . slug . ".md"
  exe "edit " . article_path
endfunction

command! -nargs=1 ZennCreateArticle call <SID>create_zenn_article(<f-args>)
" }}}

" {{{ other
set background=light
colorscheme iceberg
filetype plugin indent on

command! MYVIMRC execute 'edit ~/dotfiles/vim/rc/_vimrc'
command! MYGVIMRC execute 'edit ~/dotfiles/vim/rc/gvimrc'
command! DOT execute 'cd ~/dotfiles'

function g:RandomColorScheme()
	let l:mycolors = split(globpath(&rtp,"**/colors/*.vim"),"\n") 
	let l:seed = srand()
	let l:rnd = rand(l:seed) % len(l:mycolors)
	execute 'source ' . l:mycolors[l:rnd]
	unlet l:mycolors
endfunction

"if has('vim_starting')
" call g:RandomColorScheme()
"
" let s:save_cpo = &cpo
" set cpo&vim
"
" function! s:build_palette() abort
"	let g = {}
"	let c = {}
"
"	let g = {
"	\ 'statuslinenc_fg' : hlget('StatusLineNC', v:true)[0]['guifg'],
"	\ 'statuslinenc_bg' : hlget('StatusLineNC', v:true)[0]['guibg'],
"	\}
"	let c = {
"	\ 'statuslinenc_fg' : hlget('StatusLineNC', v:true)[0]['ctermfg'],
"	\ 'statuslinenc_bg' : hlget('StatusLineNC', v:true)[0]['ctermbg'],
"	\}
"
"
"	let p = {
"		 \ 'normal':   {},
"		 \ 'inactive': {},
"		 \ 'insert':   {},
"		 \ 'replace':  {},
"		 \ 'visual':   {},
"		 \ 'command':   {},
"		 \ 'tabline':  {}}
"
"	let col_base     = [g.statuslinenc_fg, g.statuslinenc_bg, c.statuslinenc_fg, c.statuslinenc_bg]
"	let col_edge     = [g.statusline_fg, g.statusline_bg, c.statusline_fg, c.statusline_bg]
"	let col_gradient = [g.statusline_fg, g.xline_gradient_bg, c.statusline_fg, c.xline_gradient_bg]
"	let col_nc       = [g.statuslinenc_fg, g.statuslinenc_bg, c.statuslinenc_fg, c.statuslinenc_bg]
"	let col_tabfill  = [g.statuslinenc_fg, g.statuslinenc_bg, c.statuslinenc_fg, c.statuslinenc_bg]
"	let col_normal   = [g.statusline_fg, g.statusline_bg, c.statusline_fg, c.statusline_bg]
"	let col_error    = [g.statusline_fg, g.red, c.normal_bg, c.red]
"	let col_warning  = [g.statusline_fg, g.orange, c.normal_bg, c.orange]
"	let col_insert   = [g.statusline_fg, g.blue, c.normal_bg, c.blue]
"	let col_replace  = [g.statusline_fg, g.orange, c.normal_bg, c.orange]
"	let col_visual   = [g.statusline_fg, g.purple, c.normal_bg, c.purple]
"	let col_command   = [g.statusline_fg, g.green, c.normal_bg, c.green]
"	let col_tabsel   = [g.statusline_fg, g.statusline_bg, c.statusline_fg, c.statusline_bg]
"
"	let p.normal.middle = [
"		 \ col_base]
"	let p.normal.left = [
"		 \ col_normal,
"		 \ col_gradient]
"	let p.normal.right = [
"		 \ col_edge,
"		 \ col_gradient]
"	let p.normal.error = [
"		 \ col_error]
"	let p.normal.warning = [
"		 \ col_warning]
"
"	let p.insert.left = [
"		 \ col_insert,
"		 \ col_gradient]
"	let p.replace.left = [
"		 \ col_replace,
"		 \ col_gradient]
"	let p.visual.left = [
"		 \ col_visual,
"		 \ col_gradient]
"	let p.command.left = [
"		 \ col_command,
"		 \ col_gradient]
"
"	let p.inactive.middle = [
"		 \ col_nc]
"	let p.inactive.left = [
"		 \ col_nc,
"		 \ col_nc]
"	let p.inactive.right = [
"		 \ col_nc,
"		 \ col_nc]
"
"	let p.tabline.middle = [
"		 \ col_tabfill]
"	let p.tabline.left = [
"		 \ col_tabfill]
"	let p.tabline.tabsel = [
"		 \ col_tabsel]
"
"	let p.tabline.right = copy(p.normal.right)
"
"	return p
" endfunction
"
"
" let g:lightline#colorscheme#mystatusline#palette = s:build_palette()
"
"
" let &cpo = s:save_cpo
" unlet s:save_cpo
" call lightline#update()
"endif

" }}}
